#summary Ela language reference
#labels Featured

= Language Reference =

= Bindings =

==Introduction==
This article discusses bindings (similar to variable declarations in imperative languages) in Ela.


==Overview==
Unlike imperative languages Ela doesn't have a concept of _variables_. Instead like other functional languages Ela has a concept of _binding_. Binding basically
binds an expression to a given name. Unlike variables which can change their values through the code bindings are always immutable. There is no support for mutable variables
in Ela. Also Ela even doesn't have a so called _assignment_ operator. An operator `=` which you can see in bindings is a special form that is only used to bind an
expression to a name:

{{{
let x = 2
x = 3 //Not a valid Ela code!
}}}

Another important difference from imperative language is that Ela supports _name shadowing_. For example, the following code is completely valid:

{{{
let x = 2
let x = 3
}}}

But it is important to understand this example correctly. Here we don't mutate the value of `x` (which is impossible) we simply use the same name for a different
expression. The following example can illustrate how it works:

{{{
let x = 2
//A function for one argument that captures x from the global scope
let sum y = y + x
let x = 3
sum 2
}}}

This code evaluates to `4` (not to `5`) because function `sum` was declared before we made a re-binding of a name `x`.

Bindings in Ela like in many other languages has a lexical scoping. Global bindings in Ela module are by default included in the export list and can be referenced from other modules.

Another important thing to remember about bindings in Ela is that names used in bindings should never start with a capital letter. The following code results in an error:

{{{
let Foo = 42
}}}

This is because identifiers that start with a capital letter are used for _variant tags_.


==Global Bindings==
Global bindings have the following syntax:

{{{
let [attributes] pattern = expr

//Guarded equations
let [attributes] pattern | guard1 = expr1 { | guardN = exprN }
                         | else   = exprN

}}}

The _attributes_ clause is optional and can contain one or more binding attributes (see section _Binding Attributes_ for details). The simple case of a mandatory
_pattern_ clause is an identifier however it can be any supported pattern: 

{{{
let x = 2
let (x::xs) = [1..10]
let (Foo x,(1,[y,z])) = (Foo 42,(1,[3,4]))
let _ = () //Here we simply ignore the value of right-hand expression
}}}

One can also uses guards in bindings:

{{{
let y = 0
let x | y > 0 = y
      | else  = 0
}}}

This code is equivalent to the following:

{{{
let x = if y > 0 then y else 0
}}}

An `else` clause is mandatory. The rest of the syntax is pretty similar to the one used in Haskell.

Global bindings can only appear at the top level. It is a syntax error to use the binding syntax described here in local scopes.


==Local Bindings==
Local bindings can be declared using two constructs - `let/in` bindings and `where` bindings. Binding made using `let/in` have the following syntax:

{{{
let [attributes] pattern = expr1 in expr2

//Guarded equations
let [attributes] pattern | guard1 = expr1 { | guardN = exprN }
                         | else   = exprN
 in exprN

}}}

The syntax is similar to the one used for global bindings except of a mandatory `in` clause. The `in` clause should contain an expression in which (and only in
which) the binding will be visible, e.g.:

{{{
let x = 2 in x*2
let y = x //Error ELA302: Name 'x' is not defined

}}}

These bindings can appear both at top level and in local levels.
Bindings done using `where` have the following syntax:

{{{
expr1
where [attributes] pattern = expr2

//Guarded equations
exprN
where [attributes] pattern | guard1 = expr1 { | guardN = exprN }
                           | else   = exprN
}}}


The syntax is similar to the `let` bindings however `where` bindings following mathematical notation and are placed after scope in which they are used.
A simple example of a `where` binding:

{{{
x 
where x = 2
}}}

Which is completely equivalent to:

{{{
let x = 2 in x
}}}

==Mutually Recursive Bindings==
Mutually recursive bindings are declare using `et` keyword:

{{{
let take (x::xs) = x :: skip xs
    take []      = []
 et skip (_::xs) = take xs 
    skip []      = []
}}}

These are similar to `and` bindings in ML and allow to reference names before they are declared. Recursive bindings
can be both top-level and local. They can be done through `let` and through `where` bindings. If you use attributes
in your bindings they will be applied to all bindings in a chain.


==Binding Attributes==
Currently Ela supports the following binding attributes:
||*private*||A binding is private and not included in the module export list (valid only on global bindings).||
||*extends*||A binding is a function that extends an already defined function with additional pattern matching clauses.||
||*inline*||A binding is a function that should be inlined when possible.||


= Functions =

==Introduction==
This article discusses function declaration in Ela.


==Declaration==
Functions in Ela are first class values and are declared using regular binding syntax like so:

{{{
let sum x y = x+y
}}}

Functions are curried therefore the declaration above is equivalent to the following declaration:

{{{
let sum x = sum'
            where sum' y = x+y
}}}

Ela also supports anonymous functions syntax. The function above can be also written like so:

{{{
let sum = \x y -> x+y
}}}

or like so (taking into account that the function is curried):

{{{
let sum = \x -> \y -> x+y
}}}

Functions in Ela can be declared using both `let` and `where` bindings.


==Operators==
Strictly speaking Ela doesn't have a concept of operators. Instead it recognizes two types of idenfiers for functions - a regular type (which is a standard Ela identifier)
which is used for functions called in prefix notation by default and a symbolic idenfier which is used by default in infix (or postfix) notations. 
Therefore declaration of operators is effectively the same as declaration of functions:

{{{
let (+.) x y = x+y
}}}

This function is basically equivalent to the `sum` function shown in the begging of the previous section. The only difference is that by default
it is applied using infix notation:

{{{
x +. y
}}}

==Application Notation==
"By default" means that prefix, postfix and infix notations are possible for any functions in Ela. For example operators can be applied using prefix notation:

{{{
(+) 2 2
}}}

And even postfix notation:

{{{
2+
}}}

The latter code partially applies an operator `+`. However for unary operators it will result in saturation.
Functions also can be called using infix and postfix notations:

{{{
2 `sum` 2
}}}

or even

{{{
2 `sum`
}}}

which has effectively the same effect as a right section for `+` shown above.

You can also declare functions and operators using all these notations:

{{{
let sum x y = x+y //Prefix
let x +. y = x+y //Infix
let x+++ = x+x //Postfix
}}}

==Pattern Matching==
Functions in Ela can be defined using pattern matching. In such a case a function will have a separate body for each of the match entries. A typical example is a
known `map` function:

{{{
let map _ [] = []
    map f (x::xs) = f x :: map f xs
}}}

Here we have a function for two arguments that accepts a function (as a first argument) and a list (as a second argument). A list is deconstructed using head/tail pattern.

One can also use guards in functions (in the same manner as in bindings):

{{{
let filter _ [] = []
    filter p (x::xs) | p x  = x :: filter p xs
                     | else = filter p xs
}}}

==Extensible Functions==
One function can extend another function by adding additional match clauses. Such a function can be declared using `extends` attribute. For example, this how
one can extend a standard prelude `+` function:

{{{
let extends (Box x) + (Box y) = x+y
}}}

Without `extends` attribute it will simply shadow an existing declaration.
Now application in a form: `Box 2 + Box 2` would evaluate to `4` as well as `2+2`.
Functions marked with `extends` attribute are evaluated in order - starting from the function that was declared last. Also it is important to understand that
such a declaration doesn't mutate anything - it simply creates a new binding that includes a body of previously defined function.


= Primitive Types =

==Introduction==
This article discusses primitive types in Ela.


==Booleans==
Booleans can be created using `true` and `false` literals:

{{{
let t = true
let f = false
}}}

Unlike many other languages booleans in Ela don't support explicit conversion to/from integer numbers. 

One can use prelude functions `not`, `==` and `<>` with booleans:

{{{
not true == false $
true == true $
true <> false
}}}

The following prelude functions returns booleans as a result: `not` (logical negation), `==`
(equality), `<>` (inequality), `>` (greater), `>=` (greater or equal),
`<` (lesser), `<=` (lesser or equal).


==Numeric types==
Ela has four numeric types - 32-bit integers, 64-bit integers, 32-bit floats and 64-bit floats. In the current
implementation all these types are mapped respectively to .NET Framework types `System.Int32`,
`System.Int64`, `System.Single` and `System.Double`. All these types have their special
literal syntax:

{{{
let i = 42 //integer
let l = 42L //long
let f = 1.42 //float
let d = 1.42 //double
}}}

Prelude defines multiple arithmetic functions such as `+` (addition), `-` (subtraction), `*`
(multiplication), `/` (division), `%` (remainder), `**` (power), `--` (unary negation).
All these functions support implicit conversions between these types.
Once can also use bitwise operators from prelude with integer numbers: `&&&` (bitwise AND), `|||`
(bitwise OR), `^^^` (bitwise XOR), `<<<` (left shift), `>>>` (right shift) and
`~~~` (bitwise not).


==Strings and chars==
Strings in Ela are unicode sequences of characters. In the current implementation they do map directly to the .NET Framework data type 
`System.String`. Chars are unicode characters.

{{{
let s = "Hello, world!"
let c = 'C'
}}}

Quoted string literals support C-style escape codes:

{{{
let s = "Hello,\r\nworld!"
}}}

Ela also supports a special literal for multiline strings:

{{{
let s = <[ Multiline
  string ]>
}}}

Strings and chars can be compared using all standard prelude comparison operators. In order to concatenate strings one can use `++`
function from prelude.


==Unit==
Unit is a "replacement for null" in Ela. Many functional languages use a unit type instead of a null. Unit has its own literal in Ela:

{{{
let u = () //u now is unit
}}}

Unlike null unit is an actual value. You can even apply functions to unit:

{{{
() == ()
}}}

Unit is useful in cases where there is no other meaningful value that can be returned.

= Tuples =

==Introduction==
This article discusses a tuple type which is widely used in Ela.


==Overview==
Tuple is a grouped sequence of values. They can be useful in cases when you need a simple join of several values (such as to return several values from a function).
Tuples can be creates using special literal syntax:

{{{
let t = (1,2,3)
}}}

Note that `,` is not an operator in Ela but syntax. However one can easily write a function that constructs tuples like so:

{{{
let x => y = (x,y)
1 => 2 => 3 == (1,2,3)
}}}

The reason why this code produces a single "flat" tuple is because tuples in Ela are always flat (a similar behavior can be found in _Pure_). It is not possible
to create tuple that has other tuples as its elements:

{{{
((1,2),3) == (1,2,3)
}}}

Tuples are always compared using structured equality. Tuples are immutable as all Ela data structures - there is no way to add or to change an element.

= Records =

==Introduction==
This article discusses a record data type.


==Overview==
Records are pretty similar to tuples but provide an ability to access their elements by name. Records in Ela are effectively associative immutable arrays which elements can
be accessed both by index and by name. One can use the following literal form to construct records:

{{{
let r = {x = 1, y = 2}
}}}

It is possible to name record fields using a combination of symbols that is not valid for Ela identifier:

{{{
let r = { "long field name" = 1, y = 2 }
}}}

Also if you assign record fields with values of variables Ela can infer field names like so:

{{{
let x = 1
let y = 2
{x,y} = {x=1,y=2}
}}}

Records are always compared using structural equality. Also it is not possible to change elements of records or to add new elements. However you can "clone" existing records
and create new records that "inherit" their attributes. This done using concatenation function `++`:

{{{
let r1 = {x=1,y=2}
r1 ++ {z=3} == {x=1,y=2,z=3}
}}}

Concatenation of course always produce a new record.

= Lists =

==Introduction==
This article discusses a single linked list data type.


==Overview==
Lists in Ela are implemented as immutable single linked list. Such a data structure can be found in most functional languages. Lists can be constructed using _cons_ operator 
(declared as `::` in prelude):

{{{
let xs = 1::2::3::[]
}}}

A `[]` literal denotes an empty list (usually called _nil list_). Operator `::` is right associative and when you construct lists using this operator the
right-most operand should be always a nil list.

One can also use a special literal syntax for list construction. The code above is fully equivalent to:

{{{
let xs = [1,2,3]
}}}

As soon as Ela is a dynamically typed language lists can contain values of any type. Also, unlike tuples, lists can be nested.

= Ranges =

==Introduction==
This article discusses ranges in Ela.


==Overview==
Ranges in Ela are arithmetic sequences that can be used to generate lists. 
You only have to specify a first element, a last element, and (optionally) a second element that will be used to calculate stepping.



==Strict Ranges==
Ranges are created using special literal syntax:

{{{
"[" first[,step]..[last] "]"
}}}

Here is an example of a simple range:

{{{
[1..10]
}}}

You can specify an optional step in a range:

{{{
[1,3..10]
}}}

If the first element of a range is lesser than the last element of a range is mandatory:

{{{
[10,9..1] $ [10,7.. --10]
}}}

Ranges can contain numeric types or tuples:

{{{
[(1,2)..(10,20)] == [(1,2),(2,3),(3,4),(4,5),(5,6)]
}}}

==Non-strict Ranges==
It is possible to construct non-strict ranges (such as infinite lists). In this case the last element in range should be omitted:

{{{
[1..] $ [1,8..] $ [100,98..]
}}}


= Comprehensions =

==Introduction==
This article discusses comprehensions in Ela.


==Overview==
Ela supports list comprehensions in Haskell style (with slightly altered syntax). Comprehensions can be used to produce both strict and lazy lists.

==Strict Comprehensions==
Comprehension consists of three parts â€“ a value to select, an expression that actually fetches a value and an optional condition (guard clause). Let's say that we have a range [1..10] and 
we need to select all even integers from it, multiply each element by two and compile a new list with the result:

{{{
[x `*` 2 \\ x <- [1..10] | x % 2 == 0]
}}}

Guard clause is not mandatory and can be omitted:

{{{
[x `*` 2 \\ x <- [1..10]]
}}}

You can also use multiple guards like so:

{{{
[x `*` 2 \\ x <- [1..10] | x % 2 == 0 | x > 5]
}}}

The code above is fully equivalent to:

{{{
[x `*` 2 \\ x <- [1..10] | x % 2 == 0 or x > 5]
}}}

You can generate a list based on several inputs like so:

{{{
[x `*` y \\ x <- [10,9..1], y <- [1..10] | x % 2 == 0 and x > 5]
}}}

Guards can be attached to each selector in comprehension. You can also use pattern matching in selectors and reference names declared in preceding selectors:

{{{
[x `*` y \\ x <- [10,9..1] | x % 2 == 0, y <- [x..10] | y > 5]
}}}

==Lazy Comprehensions==
Comprehensions can be used to generate lazy lists. In this case a comprehension should start with an ampresand character (`&`):

{{{
[& x \\ x <- [1..]]
}}}

Lazy comprehensions support the same features as strict comprehensions.

= Variants =

==Introduction==
This article discusses a variant data type.


==Overview==
Variants in Ela are somewhat similar to _polymorphic variants_ in OCaml language. This is a pretty straightforward data type. It allows you to attach a tag to a particular
value like so:

{{{
let x = Some 12
}}}

Tags should always start with a capital letter (unlike variables which never start with a capital letter).

Variants may be useful in cases when you want to associate additional information with value. For example, consider a safe division function:

{{{
let x /. 0 = None
    x /. y = Some (x/y)
}}}

This function is defined through pattern matching and returns variant `None` if a divider is zero, otherwise it returns a result of division 
packed in a variant `Some`.

The literal form for variant has the following syntax:

{{{
Tag [expr]
}}}

For convenience `expr` clause is optional as you have seen in example above, however creating a variant like so `None` has exactly the same effect
as the following expression: `None ()`. In other words a variant created without an argument automatically wraps a unit value.

Also unlike OCaml language variant tags in Ela can't be attached to several values. For example the following code would result in an error:

{{{
let v = Some 1 2
}}}

In order to attach a variant tag to several values one can use tuples like so:

{{{
let v = Some (1,2)
}}}

==Pattern Matching==
Variants can be deconstructed using pattern matching - with effectively the same syntax as used for their literal form:

{{{
let x = Some 12
let (Some y) = x
y //equals 12
}}}

It is imporant to remember that a variant pattern should be always enclosed in parenthesis.

= Thunks =

==Introduction==
This article discusses a thunks and writing non-strict code in Ela.


==Lazy Evaluation==
Ela by default is a strict language (like for example C#) but it does provide an extensive support for lazy evaluation. However unlike languages like Haskell lazy evaluation in Ela
is always explicit - one should mark a particular section of code as _thunk_ to enable laziness.

This is done using built-in syntax like so:

{{{
let x = (& 2+2)
}}}

An evaluation of expression enclosed in parenthesis with ampersand is deferred. Also such an expression is evaluated just once (and after that its value is memoized).

An expression which evaluation is deferred is called _thunk_. Thunks are calculated only when their value is actually needed. For example standard prelude operator `+`
(additional) is strict - therefore if you apply this operator to a thunk a thunk will be immediately evaluated. 

However one can write a function with a non-strict semantics. For example a simple tuple construction function defined like so:

{{{
let x => y = (x,y)
}}}

is non-strict as soon as it doesn't evaluate its arguments. If you pass thunks to this function you will get a tuple with thunks. 

==Lazy Lists==
Some standard prelude functions are also non-strict. For example, list construction function (`::`) is non-strict. It doesn't evaluate the tail of a list. If you pass a thunk as
a list tail it will construct a lazy list:

{{{
let xs = 1::2::[] //strict list
let xs' = 1::(& 2::[]) //lazy list
}}}

The same for concatenation operator `++`. When used with lists it can construct lazy lists as well as strict lists.

A lazy list in the example above is not very useful, however one can easily writen a function that generates an infinite list like so:

{{{
open Core
let inf x = x :: (& inf <| x+1)
take 10 <| inf 0

}}}

A function `take` is defined in `Core` module and takes first 10 elements from a list. A lazy list is evaluated on demand only. 
In example above we have taken first 10 elements from this list - only ten elements are evaluated.

One can define other lazy functions in a similar manner. For example this how a lazy `map` function 
(which takes a function and a list and maps this functions to the elements of a list) can be defined:

{{{
let map _ [] = []
    map f (x::xs) = f x :: (& map f xs)

}}}

And now we can safely map our infinite list using this function:

{{{
let xs = map (*2) (inf 0)
take 10 <| xs
}}}

The code above evaluates to: `[0,2,4,6,8,10,12,14,16,18]`.



==Forcing Evaluation==
One can force an evaluation of a thunk using prelude `force` function like so:

{{{
let t = (& 2+2)
force t
}}}

Also thunks are automatically forced when used in sequence expressions (created using built-in `$` operator).

= Pattern Matching =

==Introduction==
This article discusses pattern matching in Ela and lists all available patterns.


==Pattern Matching Constructs==
===Match Expression===
The main language construct for pattern matching is `match` expression. It has the following syntax:

{{{
match expr with
      pat [ | guard ] = expr
}}}

Match expression can have one or more match entries. A match entry consists of a pattern, an optional boolean guard and expression that is evaluated if an entry is successfully matched.
Here is an example of a simple match expression:

{{{
match [1,2,3] with
      x::[] = Some x
      x::xs = Some xs
      []    = None
}}}

All match entries should be indented after the `match` keyword. The order of pattern is significant as soon as patterns are always processed in order. For example if we change
the order of patterns in the example above like so:

{{{
match [1,2,3] with
      x::xs = Some xs
      x::[] = Some x
      []    = None
}}}

the second pattern `x::[]` would be unreachable because pattern `x::xs` is more generic and is tested earlier. In other words a pattern `x::xs` would work for
a list with single element and for multiple element list when pattern `x::[]` would only match agains a single element list.

Luckily Ela validates match expressions and warns if the order of patterns is incorrect. If you try to compile the above code you will receive the following warning:
`Warning ELA403: Match entry 'x::[]' is not reachable because it is overlapped by a preceding entry 'x::xs'.

Hint ELA502: Consider reordering match entries. Less specific patterns should be moved after more specific patterns.`
You can also use guards in match entries in the same manner as in bindings. Here is an example of a guarded match entry:

{{{
match [1,2,3] with
      x::[] | x > 0 = Some x
            | else  = None
      x::xs = Some xs
}}}

Also it is possible to use `where` bindings to declare names that are scoped to a particular match entry:

{{{
match [1,2,3] with
      x::[] | gtz  = Some x
            | else = None
            where gtz = x > 0
      x::xs = Some xs
}}}

If none of the patterns match than a `MatchFailed` exception is raised. This exception can be handled in Ela code, however if you wish to prevent generation of this exception
you can add a so called "default" to clause to a match entry.
For example, the match expression above is non-exhaustive - it will fail for an empty list. Adding a default clause like so:

{{{
match [1,2,3] with
      x::[] | gtz  = Some x
            | else = None
            where gtz = x > 0
      x::xs = Some xs
      _     = Error
}}}

will prevent generation of an exception. 
Default clause should be always the very last entry as soon as it matches any value. Usually a wildcard (`_`) pattern is used in default clause. This pattern matches
any value and disregards this value. However if you need the value you can a variable pattern instead (it will also match with any value and additionally bind a variable to this
value).


===Is Expression===
Expression `is` represents a lightweight version of a `match` expression. It is useful if you want to compare a value with a single pattern. For example:

{{{
[1,2,3] is (x::xs)
}}}

Another peculiarity of `is` expression is that it doesn't generate an exception if a match fails, instead it returns a boolean value - `true` if a match was
a success, otherwise - `false`.
All bindings done with `is` expression are in a private scope. If you write `is` expression at top level, bindings are not lifted to global scope. If you
want to use names bound by `is` expression in your code, you can embed it in an `if` expression like so:

{{{
if [1,2,3] is (x::xs) then 
  do_something xs 
else 
  do_something_else ()
}}}

However it is probably better to use other pattern matching constructs in such cases.


===Binding Patterns===
You can also use pattern matching in `let` and `where` bindings. Basically these bindings are always defined using pattern matching with variable pattern as
a trivial case:

{{{
let xs = [1..10]
}}}

It is possible however to use any patterns and guards in bindings as well:

{{{
let (x::xs) = [1..10]
let (Some x) = Some 42
}}}

===Functions===
One can use pattern matching in function declarations - in the argument list like so:

{{{
let tail (x::xs) = xs
}}}

In such a case patterns are separated by spaces and one pattern matches exactly one argument. When matching inside an argument list head/tail pattern and variant pattern should
be always enclosed in parens.


===Exception Handling===
A construct used for exception handling - `try/with` expression - has effectively the same syntax as `match` expression with `try` keyword instead of
`match`. The major difference is that it doesn't match a given expression but executes it and if (and only if) this expression fails matches an exception object.


==Patterns==
All patterns can be divided in two groups - irrefutable patterns that always match (such as variable pattern that always does the binding even if the value is unit) and refutable
patterns that may not match. Patterns can be nested at any level.
Ela supports the following patterns:
|| *Pattern*|| *Grammar*|| *Example*|| *Description*||
||Name||ident||x||Irrefutable pattern, binds a value to a name.||
||As||pattern@name||(x::xs)@list||Irrefutable pattern, binds an expression to a name.||
||Wildcard||_||_||Irrefutable pattern, always matches and disregards a value.||
||Group||( pattern )||(x::xs)||Grouping pattern, used to group patterns.||
||Unit||()||()||Refutable pattern, matches unit.||
||Literal||literal||"string"||Refutable pattern, matches a given literal. Numeric literal, string, chars and booleans are supported.||
||Tuple||(pattern{,pattern})||(x,1,(x::xs))||Refutable pattern, matches tuple.||
||Record||{pattern{,pattern}}||{x,y,z} or {x'=x,y=y'}||Refutable pattern, matches a record and binds its fields to names. If names are not specified than it creates bindings witd tde same names as record fields.||
||List||[pattern{,pattern}]||[1,2,x]||Refutable pattern, matches a linked list of a specified lengtd.||
||Head/Tail||pattern{::pattern}||x::(1,2)::xs||Refutable pattern, matches a linked list. Instead of a list pattern it doesn't test a list length and if tde last pattern is a name pattern binds tdis name to a list tail.||
||Variant||Tag pattern||Some x||Refutable pattern, matches a variant.||
||Type Check||?typename||?unit||Refutable pattern, matches if a type of an expression equals to tde specified type.||


= Exceptions =

==Introduction==
This article discusses exception handling in Ela.


==Exceptions in Ela==
Exception in Ela are represented using variants. A typical exception contains a tag and exception data. Normally exception data is a string message,
however it can be data of any type. One of the typical tags used for exceptions in Ela is `Failure`. Standard library generates only exceptions
with `Failure` tag.


==Handling Exceptions==
Ela provides a support for structured exception handling in the same way as C-style language. A `try/with` expression is used to handle exceptions:

{{{
try 2 / 0 with
    DivizionByZero = 0

}}}

This expression has effectively the same syntax as `match` expression and support pattern matching with multiple clauses is well. When expression that follows
`try` keywords doesn't fail `try/with` returns a value of this expression. If it fails than an exception is matched against patterns that follows
`with` keyword.


==Generating Exceptions==
In order to generate exceptions one can use a `raise` statement. It has the following syntax:

{{{
raise Tag expr
}}}

An exception should include a variant tag (that denote a type of an exception) and exception data (which can be any expression). Expression that is used to represent
exception data is always evaluated in a strict manner. Example of `raise` statement:

{{{
raise DivisionByZero "You cannot divide by zero!"
}}}

There is also a shorter statement `fail` which always generates exceptions with tag `Failure`. This tag is commonly used in Ela code.

{{{
fail "Nil list!"
}}}


= Modules =

==Introduction==
This article discusses modules in Ela.


==Overview==
Modules in Ela are separate translation units. The only way to create a module is to create a separate .ela file. Each .ela file is a module and
every module is an .ela file. Therefore a program in Ela consists of at least one module. The name of this module is the name of a file without an
extension, e.g. file Core.ela represents a module Core.


==Referencing Modules==
Modules can be referenced using `open` statement. This statement can be appear only at top level. It has the following syntax:

{{{
open [ "qualified" ] {path "."} module["#" dll]["@" alias] 
     ["(" { [ "private" ] name [ "=" localName ] "," } ")" ]
}}}

A simplest form of this statement only includes a module name like so:

{{{
open Core
}}}

Ela linker will try to resolve the path of this module based on the lookup directories provided via configuration. 
By default Ela automatically imports all names from module. If several modules define the same set of names they will shadow each other. If
this is not a desired behavior you can restrict automatic name import by specifying a `qualified` attribute:

{{{
open qualified Core
}}}

Now in order to reference a name from module you will have to qualify it with the module alias:

{{{
let map = Core.map
let (+) = Prelude.(+)
}}}

(You can also reference module fields through the module name even if `qualified` attribute is not specified. This attribute only disallows
automatic import of names).
It is possible to specify a relative path to the module as well using a dot-notation like so:

{{{
open code.samples.Foo
}}}

In this case Ela linker will look a module in a `code\samples` directory relative to all lookup directories.
When opening foreign modules implemented in .NET it is required to specify a DLL name after the hash sign like so:

{{{
open String#elalib
}}}

By default a module will have an alias that is equal to its name. You can however give a different alias to module like so:

{{{
open Char@ch
}}}

Now you can referencing names in the module `Char` through `ch` name.
Also `open` directive supports an explicit import list like so:

{{{
open qualified Core ( private map, filter, foldl = fold )
}}}

In code example above the following local names will be created: `map` with the provide modifier, `filter` with the public modifier
(so you will be able to reference it from another module) and `fold`, mapped to `foldl` from `Core` module.


==Export List==
By default all global bindings are included in the export list of a module. If you want to exclude some bindings from export list you should add a
`private` modifier to this bindings:

{{{
let private foo = Foo
}}}

==First class Modules==
Modules in Ela are first-class values and can be treated as records. Consider the following example:

{{{
open qualified Core
let get f x = x:f

let _ = get "e" {e=Core.e}
let _ = get "e" Core

}}}


= Ela Operator Priority =

==Introduction==
This article discusses operator priority and associativity in Ela.


==Operator Symbols==
In Ela operator identifiers can include only the following symbols: `!%&*+-.:/\<=>?@^|~`. Some of the symbols are already used by language constructs.
For example, it is not possible to define an operator `&` as soon as the one is already used to denote lazy lists and lazy expressions. However it is possible
to define an operator `&.`, etc. 

All standard arithmetic operators such as `+`, `-`, etc., composition operators, application operators and so on are not syntax but functions defined in 
Prelude and therefore can be easily redefined.

==Reserved Operators==
The following combinations of operator symbols are reserved and cannot be used in custom operators:
||&||Lazy sections||
||->||Lambda operator||
||`|`||Guard||
||@||As-pattern||
||=||Binding||
||\||Lambda operator||
||\\||Comprehension operator||

==Priority and Associativity==
In Ela operator priority and associativity is controlled by the first symbols in operator identifier. The following table lists all operator priorities in order, starting
from the loose operators. A notation `{op}` is used to show that any number (zero or more) of trailing operator symbols is allowed here. For example, priroty of
operators `=|` and `=||` is the same.
|| *Operator Symbols*|| *Priority*|| *Associativity*||
||= {op}||1||Left||
||| {op}||1||Left||
||& {op}||1||Left||
||< {op}||1||Left||
||> {op}||1||Left||
||<| {op}||2||Right||
||^ {op}||3||Left||
||: {op}||4||Right||
||+ {op}||5||Left||
||- {op}||5||Left||
||`*` {op}||6||Left||
||/ {op}||6||Left||
||% {op}||6||Left||
||<< {op}||7||Right||
||>> {op}||8||Left||
||~ {op}||9||Left||
||-- {op}||9||Left||
||! {op}||9||Left||
||? {op}||9||Left||
||. {op}||9||Left||